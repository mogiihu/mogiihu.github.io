{
    "sourceFile": "src/content/posts/2020-11-15-Taro3升级指南/index.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1756112365584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756112377440,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,235 +8,67 @@\n draft: false \n lang: ''\n ---\n \n-> 身为一个前端，HTTP 对我而言就像是云雾环绕的一座山，看不透也不知从哪开始攀登。深入学习 HTTP 协议系列就是我对罗剑锋老师的[《透视 HTTP 协议》](http://gk.link/a/10mzW)所做的总结。希望能对大家的登山之旅有所帮助。\n+## Taro 3.x 时代\n \n-## 当我们在浏览器地址栏输入网址再按下回车发生了什么？\n+Taro 在今年 7 月份正式推出推出 3.0 版本，与 Taro1/2 编译型架构不同，Taro3 是一种解释型架构。可以让开发者获得完整的 React/Vue 等框架的开发体验。\n \n-1. 浏览器发起域名解析获取地址对应的 IP；\n-2. 浏览器用 TCP 的三次握手与服务器建立连接；\n-3. 浏览器向服务器发送拼好的报文；\n-4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；\n-5. 浏览器解析报文，渲染输出页面。\n+## 升级之旅由此开始\n \n-域名解析的过程中有多级缓存，浏览器先查看自身缓存，没有再向操作系统缓存要，还没有就检查本机域名解析文件 hosts，最后则会用 DNS 域名解析系统进行。在这个过程中可能会经历 CDN 解析，拿到 CDN 服务器的地址\n+### 项目版本信息\n \n-在达到目标服务器后，通常会经历负载均衡设备，负载均衡设备会访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish。\n-\n-如果缓存服务器里没有所要数据，就会把请求转发给应用服务器，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。然应用服务器处理完成后把执行的结果返回给负载均衡设备。\n-\n-到达负载均衡后请求的处理就完成了，会按照请求顺序原路返回。\n-\n-## HTTP 协议的核心部分 - HTTP 报文\n-\n-### 报文结构\n-\n-HTTP 协议的请求报文和响应报文的结构由三大部分组成\n-\n-1. 起始行（start line）：描述请求或相应的基本信息；\n-2. 头部字段集合（header）：key-value 的形式；\n-3. 消息正文（entity）：实际传输数据。\n-\n-其中前两部分经常被称为 **请求头/响应头**，正文部分称为**body**。\n-\n-HTTP 协议规定报文必须有 header，可以没有 body，在 header 和 body 之间必须有一个空行，如下图所示。\n-\n-![报文结构](./img1.png)\n-\n-### 抓包分析\n-\n-![抓包分析](./img2.png)\n-\n-图中 1，第一行为请求行部分。2，为 header 部分，3 是空白行部分。这里没有发送 body，所以没有 body 信息。\n-\n-### 请求行\n-\n-报文的起始行就是请求行，它简要的描述了客户端想要如何操作服务器端的资源。\n-\n-```js\n-GET / HTTP / 1.1;\n ```\n+Taro: 2.1.5 -> 3.0.15\n+React: / -> 17.0.0\n+```\n \n-在抓包获取的信息中，我们可以看到请求头由三部分组成：\n+### 项目初始化\n \n-1. 请求方法，表示对资源的操作，对应上面代码中的 GET，；\n-2. 请求目标，通常是一个 URI，表记录请求方法要操作的资源，对应 `/`；\n-3. 版本号：表示报文使用的 HTTP 协议版本，对应 `HTTP/1.1`。\n+最初，我按照 Taro 官方提供的[迁移指南](https://taro-docs.jd.com/taro/docs/migration)上的步骤进行升级。但是由于 Taro3 的 babel 配置及 webpack 配置发生改变，有大量的 npm 包缺少或是剩余，项目报错不好排查。所以我决定采从新建项目开始，让 taro init 帮我们解决一些基本的项目配置工作。\n \n-这三个部分通常用空格来分隔，最后用 CRLF 换行表示结束，用图片来描述就是下面这个方式。\n+首先全局安装 @tarojs/cli , 使用 taro 进行项目初始化。\n \n-![请求行](./img3.png)\n-\n-### 状态行\n-\n-服务器响应报文里的起始行叫做**状态行**，表示**服务器响应的状态**。\n-\n-```js\n-HTTP/1.1 200 OK\n-HTTP/1.1 404 Not Found\n+```shell\n+npm install -g @tarojs/cli\n+taro init myApp\n ```\n \n-也由三部分组成：\n+下面是我的安装选项：\n \n-1. 版本号，表示报文使用的 HTTP 协议版本号；\n-2. 状态码，表示处理结果，如 200 成功，500 服务器错误；\n-3. 原因：作为数字状态码的补充，在上面代码是 `OK`。\n+![项目初始化](./img1.png)\n \n-它的组成规则和请求行一致，用空格来分隔，用 CRLF 换行表示结束，如下图所示。\n+因为之前的项目结构和生成的一致，这里就不对生成的项目结构进行改变，进行下一步：修改 config 配置。\n \n-![状态行](./img4.png)\n+![项目初始化](./img2.png)\n \n-### 头部字段（header）\n+### 开发配置\n \n-请求行/状态行加上头部字段（header），就组成了请求头/响应头。\n-如下图所示：\n+在上面的目录中 config 内放置的就是有关项目配置的文件，这里 taro 帮我们自动创建了三个配置文件，`dev.js`/`index.js`/ `prod.js` ，`dev.js` 对应的是开发环境的项目配置，`prod.js` 为生产环境，`index.js` 则是在开发环境和生产环境中都会用到的配置。\n \n-![请求头/响应头](./img5.png)\n+在开发环境中，我主要添加了路径别名，用来对路径进行缩写\n \n-头部字段是 key-value 的形式，之间用 `：` 分隔，最后用 CRLF 换行表示结束。\n-\n-注意：\n-\n-1. 字段不区分大小写，不允许出现下划线`_`，可以使用短横线`-`连接。\n-2. key 后面紧跟`:`，不能有空格。但是`:`和 value 之间可以出现空格。\n-3. 字段的顺序是无意义的。\n-4. 字段原则上不能出现重复，除非字段本身语义允许，如 Set-Cookie。\n-5. 在请求头/响应头中只有 `Host` 字段是必须的。\n-\n-## HTTP 请求方法\n-\n-### 标准请求方法\n-\n-1. GET：获取资源，可以理解为读取或者下载数据；\n-2. HEAD：获取资源的元信息；POST：向资源提交数据，相当于写入或上传数据；\n-3. PUT：类似 POST；DELETE：删除资源；\n-4. CONNECT：建立特殊的连接隧道；\n-5. OPTIONS：列出可对资源实行的方法；\n-6. TRACE：追踪请求 - 响应的传输路径。\n-\n-![请求分类](./img6.png)\n-\n-### 常用方法\n-\n-#### GET 和 HEAD\n-\n-GET 的含义是**从服务器获取资源**，可以搭配 URI 和其他头部字段实现对资源更精细的操作。\n-\n-HEAD 的含义与 GET 类似，都是**从服务器获取资源**，服务器处理机制也一样，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。可以将他看做 GET 的简化版。\n-\n-#### POST 和 PUT\n-\n-POST 和 PUT 是指**向 URI 指定资源提交数据**，而 POST 和 PUT 的区别在于 POST 意味着“新建”，PUT 则是 “修改”。\n-\n-### 其他方法\n-\n-DELETE：指示服务器删除资源。\n-CONNECT：要求服务器为客户端和另一台远程服务器建立一条通道，浏览器充当代理角色。\n-OPTIONS：要求服务器列出可对资源实行的请求方法。\n-TRACE：用于对 HTTP 链路的测试或诊断。\n-\n-### 安全和幂等\n-\n-**安全**在 HTTP 协议里是指请求方法不会修改服务器上的资源。所以只有 GET 和 HEAD 是安全的，因为它们对资源进行是只读操作。\n-\n-**幂等**意思是多次执行相同操作，结果也都是相同的，即多次“幂”后“相等”。\n-\n-可以看出 GET 和 HEAD 既是安全的也是幂等的，DELETE 是幂等的，POST 和 PUT 既不安全也不幂等。\n-\n-## URI 与 网址\n-\n-URI：**统一资源标识符**，包括 URL 和 URN 两部分。\n-URL：**统一资源定位符**，就是我们俗称的“网络地址”，因为 URL 十分普遍，所以通常用 URL 表示 URL 或 URI。\n-\n-### URL 格式\n-\n-URL 本质上是一个字符串，它的作用是 唯一的标记资源的位置或者名字。它不仅能标记万维网资源，还能标记动态服务资源或者本地资源。\n-\n-它的组成部分如下图所示：由 scheme、host:port、path 和 query 组成。\n-\n-![URL 格式](./img7.png)\n-\n-URI 的第一个组成部分是 **scheme** 代表协议名，表示资源应该用那种协议访问（如：http、ftp、file）。\n-\n-scheme 之后就是固定的三个字符“**://**”，用来把 scheme 和后面的部分分离开。\n-\n-“**://**”之后是 **authority** 部分，表示**资源所在的主机名**，通常形式是 host:port ，即主机名加端口号。主机名必须要有，可以是 IP 地址或域名。端口号可以省略，浏览器等客户端会根据 scheme 使用默认的端口号，例如 HTTP 默认的是 80，HTTPS 默认的是 443。\n-\n-**path** 是用来**标记资源所在位置**。path 采用的是类似路径的表示方式，URI 的 path 必须要以 “/” 开始。\n-\n-看下面这个例子\n-\n+```js\n+const path = require(\"path\");\n+module.exports = {\n+  env: {\n+    NODE_ENV: '\"development\"',\n+  },\n+  defineConstants: {},\n+  mini: {},\n+  h5: {\n+    esnextModules: [\"taro-ui\"],\n+  },\n+  alias: {\n+    pages: path.resolve(__dirname, \"..\", \"src/pages\"),\n+    components: path.resolve(__dirname, \"..\", \"src/components\"),\n+    util: path.resolve(__dirname, \"..\", \"src/util\"),\n+    assets: path.resolve(__dirname, \"..\", \"src/assets\"),\n+  },\n+};\n ```\n-https://tools.ietf.org/html/rfc7230\n-```\n \n-`https` 是 scheme，表示使用的是 `https` 协议，`tools.ietf.org` 就是主机名，这里默认访问端口号是 443，路径就是后面的 `/html/rfc7230`。\n+在原来的 taro2 项目中还有对 babel 的配置，由于 Taro3 的项目中自动集成了 `babel-preset-taro` 包, 并且通过 `babel.config.js` 进行 babel 配置，所以新项目的 index.js 配置文件中也不需要额外添加 babel 配置，可以自行修改 `babel.config.js`。\n \n-### URI 的查询参数 query\n+### 页面配置\n \n-在上图 URL path 后还有一个 **query** 部分，query 由一个“?”开始，但不包含“?”，表示对资源附加的额外要求。\n-\n-query 的格式是由 多个 “key=value” 组成，多个 “key=value” 之间用 “&” 连接。\n-\n-### URI 的编码\n-\n-URI 中只能使用 ASCII 码，对于英语以外的汉语、日语及其他字符 URI 会对他们进行 encodeURI 转义。\n-\n-转义规则是，把字符（unicode）编码成 utf-8，utf-8 是用 1-4 个字节表示的，所以每个字节转换成 16 进制并在前面用百分号（%）连接，最后并把每个字节转换的结果连接起来。\n-\n-## 响应状态码\n-\n-### 五类状态码\n-\n-RFC 标准把状态码分成了以下五类\n-\n-- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；\n-- 2××：成功，报文已经收到并被正确处理；\n-- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；\n-- 4××：客户端错误，请求报文有误，服务器无法处理；\n-- 5××：服务器错误，服务器在处理请求时内部发生了错误。\n-\n-### 常见响应状态码及含义\n-\n-- 1xx\n-  - **101 Switching Protocols**，客户端要求服务端改成其他协议继续通信，如果服务器统一变更协议，就会返回状态码 101.\n\\ No newline at end of file\n-- 2xx\n-  - **200 OK**，表示请求成功，通常在响应头后会有 body 数据。\n-  - **204 No Content**，也表示请求成功，它与 200 的区别在于，响应头后没有 body 数据。\n-  - **206 Partial Content**，常见于获取请求资源的部分数据。“Content-Range”，表示 body 里返回数据的具体范围。\n-- 3xx\n-  - **301 Moved Permanently**，表示永久重定向。\n-  - **302 Found**，表示临时重定向，浏览器不会对临时重定向的内容做缓存优化。\n-  - **304 Not Modified**，缓存重定向，用户缓存控制，URL 不包含跳转含义。\n-- 4xx\n-  - **400 Bad Request**，表示请求错误。\n-  - **403 Forbidden**，表示服务器禁止访问资源。\n-  - **404 Not Found**，表示资源在服务器上未找到。\n-- 5xx\n-  - **500 Internal Server Error**，表示服务器发生错误，是一个较通用的错误码。\n-  - **502 Bad Gateway**，表示服务器禁止访问资源。\n-  - **503 Service Unavailable**，表示服务器正忙，暂时无法响应。\n-\n-## HTTP 的特点和优缺点\n-\n-### 五大特点\n-\n-1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；\n-2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；\n-3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；\n-4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；\n-5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。\n-\n-### 优缺点\n-\n-- 优点：\n-\n-  - 灵活可拓展；\n-  - 应用广泛，环境成熟；\n-  - 无状态，不需要额外资源来记录路状态信息，减轻服务器负担；\n-  - 明文传输，数据可直接查看到，方便开发调试。\n-\n-- 缺点：\n-  - 无状态，每次访问都要获取一遍身份信息；\n-  - 明文传输，数据容易被截取；\n-  - 不安全，数据在传输过程中容易被篡改。\n+在旧版本中，页面/项目 配置挂载在类组件的类属性或函数式的 config 属性上，通过 AST 分析取出来，生成 JSON 文件，这样无法动态生成配置。在 taro3 中，我们需要在 `页面名.config.js` ，文件中放置页面/项目的配置内容，并且该文件必须和页面/项目在同一文件夹。\n"
                },
                {
                    "date": 1756112647958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n ---\n title: Taro3升级指南\n-published: 2020-11-15 16:43:50\n+published: 2020-11-15\n description: ''\n image: ''\n tags: [小程序, 前端, Taro]\n category: '小程序'\n"
                }
            ],
            "date": 1756112365584,
            "name": "Commit-0",
            "content": "---\ntitle: Taro3升级指南\npublished: 2020-11-15 16:43:50\ndescription: ''\nimage: ''\ntags: [小程序, 前端, Taro]\ncategory: '小程序'\ndraft: false \nlang: ''\n---\n\n> 身为一个前端，HTTP 对我而言就像是云雾环绕的一座山，看不透也不知从哪开始攀登。深入学习 HTTP 协议系列就是我对罗剑锋老师的[《透视 HTTP 协议》](http://gk.link/a/10mzW)所做的总结。希望能对大家的登山之旅有所帮助。\n\n## 当我们在浏览器地址栏输入网址再按下回车发生了什么？\n\n1. 浏览器发起域名解析获取地址对应的 IP；\n2. 浏览器用 TCP 的三次握手与服务器建立连接；\n3. 浏览器向服务器发送拼好的报文；\n4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；\n5. 浏览器解析报文，渲染输出页面。\n\n域名解析的过程中有多级缓存，浏览器先查看自身缓存，没有再向操作系统缓存要，还没有就检查本机域名解析文件 hosts，最后则会用 DNS 域名解析系统进行。在这个过程中可能会经历 CDN 解析，拿到 CDN 服务器的地址\n\n在达到目标服务器后，通常会经历负载均衡设备，负载均衡设备会访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish。\n\n如果缓存服务器里没有所要数据，就会把请求转发给应用服务器，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。然应用服务器处理完成后把执行的结果返回给负载均衡设备。\n\n到达负载均衡后请求的处理就完成了，会按照请求顺序原路返回。\n\n## HTTP 协议的核心部分 - HTTP 报文\n\n### 报文结构\n\nHTTP 协议的请求报文和响应报文的结构由三大部分组成\n\n1. 起始行（start line）：描述请求或相应的基本信息；\n2. 头部字段集合（header）：key-value 的形式；\n3. 消息正文（entity）：实际传输数据。\n\n其中前两部分经常被称为 **请求头/响应头**，正文部分称为**body**。\n\nHTTP 协议规定报文必须有 header，可以没有 body，在 header 和 body 之间必须有一个空行，如下图所示。\n\n![报文结构](./img1.png)\n\n### 抓包分析\n\n![抓包分析](./img2.png)\n\n图中 1，第一行为请求行部分。2，为 header 部分，3 是空白行部分。这里没有发送 body，所以没有 body 信息。\n\n### 请求行\n\n报文的起始行就是请求行，它简要的描述了客户端想要如何操作服务器端的资源。\n\n```js\nGET / HTTP / 1.1;\n```\n\n在抓包获取的信息中，我们可以看到请求头由三部分组成：\n\n1. 请求方法，表示对资源的操作，对应上面代码中的 GET，；\n2. 请求目标，通常是一个 URI，表记录请求方法要操作的资源，对应 `/`；\n3. 版本号：表示报文使用的 HTTP 协议版本，对应 `HTTP/1.1`。\n\n这三个部分通常用空格来分隔，最后用 CRLF 换行表示结束，用图片来描述就是下面这个方式。\n\n![请求行](./img3.png)\n\n### 状态行\n\n服务器响应报文里的起始行叫做**状态行**，表示**服务器响应的状态**。\n\n```js\nHTTP/1.1 200 OK\nHTTP/1.1 404 Not Found\n```\n\n也由三部分组成：\n\n1. 版本号，表示报文使用的 HTTP 协议版本号；\n2. 状态码，表示处理结果，如 200 成功，500 服务器错误；\n3. 原因：作为数字状态码的补充，在上面代码是 `OK`。\n\n它的组成规则和请求行一致，用空格来分隔，用 CRLF 换行表示结束，如下图所示。\n\n![状态行](./img4.png)\n\n### 头部字段（header）\n\n请求行/状态行加上头部字段（header），就组成了请求头/响应头。\n如下图所示：\n\n![请求头/响应头](./img5.png)\n\n头部字段是 key-value 的形式，之间用 `：` 分隔，最后用 CRLF 换行表示结束。\n\n注意：\n\n1. 字段不区分大小写，不允许出现下划线`_`，可以使用短横线`-`连接。\n2. key 后面紧跟`:`，不能有空格。但是`:`和 value 之间可以出现空格。\n3. 字段的顺序是无意义的。\n4. 字段原则上不能出现重复，除非字段本身语义允许，如 Set-Cookie。\n5. 在请求头/响应头中只有 `Host` 字段是必须的。\n\n## HTTP 请求方法\n\n### 标准请求方法\n\n1. GET：获取资源，可以理解为读取或者下载数据；\n2. HEAD：获取资源的元信息；POST：向资源提交数据，相当于写入或上传数据；\n3. PUT：类似 POST；DELETE：删除资源；\n4. CONNECT：建立特殊的连接隧道；\n5. OPTIONS：列出可对资源实行的方法；\n6. TRACE：追踪请求 - 响应的传输路径。\n\n![请求分类](./img6.png)\n\n### 常用方法\n\n#### GET 和 HEAD\n\nGET 的含义是**从服务器获取资源**，可以搭配 URI 和其他头部字段实现对资源更精细的操作。\n\nHEAD 的含义与 GET 类似，都是**从服务器获取资源**，服务器处理机制也一样，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。可以将他看做 GET 的简化版。\n\n#### POST 和 PUT\n\nPOST 和 PUT 是指**向 URI 指定资源提交数据**，而 POST 和 PUT 的区别在于 POST 意味着“新建”，PUT 则是 “修改”。\n\n### 其他方法\n\nDELETE：指示服务器删除资源。\nCONNECT：要求服务器为客户端和另一台远程服务器建立一条通道，浏览器充当代理角色。\nOPTIONS：要求服务器列出可对资源实行的请求方法。\nTRACE：用于对 HTTP 链路的测试或诊断。\n\n### 安全和幂等\n\n**安全**在 HTTP 协议里是指请求方法不会修改服务器上的资源。所以只有 GET 和 HEAD 是安全的，因为它们对资源进行是只读操作。\n\n**幂等**意思是多次执行相同操作，结果也都是相同的，即多次“幂”后“相等”。\n\n可以看出 GET 和 HEAD 既是安全的也是幂等的，DELETE 是幂等的，POST 和 PUT 既不安全也不幂等。\n\n## URI 与 网址\n\nURI：**统一资源标识符**，包括 URL 和 URN 两部分。\nURL：**统一资源定位符**，就是我们俗称的“网络地址”，因为 URL 十分普遍，所以通常用 URL 表示 URL 或 URI。\n\n### URL 格式\n\nURL 本质上是一个字符串，它的作用是 唯一的标记资源的位置或者名字。它不仅能标记万维网资源，还能标记动态服务资源或者本地资源。\n\n它的组成部分如下图所示：由 scheme、host:port、path 和 query 组成。\n\n![URL 格式](./img7.png)\n\nURI 的第一个组成部分是 **scheme** 代表协议名，表示资源应该用那种协议访问（如：http、ftp、file）。\n\nscheme 之后就是固定的三个字符“**://**”，用来把 scheme 和后面的部分分离开。\n\n“**://**”之后是 **authority** 部分，表示**资源所在的主机名**，通常形式是 host:port ，即主机名加端口号。主机名必须要有，可以是 IP 地址或域名。端口号可以省略，浏览器等客户端会根据 scheme 使用默认的端口号，例如 HTTP 默认的是 80，HTTPS 默认的是 443。\n\n**path** 是用来**标记资源所在位置**。path 采用的是类似路径的表示方式，URI 的 path 必须要以 “/” 开始。\n\n看下面这个例子\n\n```\nhttps://tools.ietf.org/html/rfc7230\n```\n\n`https` 是 scheme，表示使用的是 `https` 协议，`tools.ietf.org` 就是主机名，这里默认访问端口号是 443，路径就是后面的 `/html/rfc7230`。\n\n### URI 的查询参数 query\n\n在上图 URL path 后还有一个 **query** 部分，query 由一个“?”开始，但不包含“?”，表示对资源附加的额外要求。\n\nquery 的格式是由 多个 “key=value” 组成，多个 “key=value” 之间用 “&” 连接。\n\n### URI 的编码\n\nURI 中只能使用 ASCII 码，对于英语以外的汉语、日语及其他字符 URI 会对他们进行 encodeURI 转义。\n\n转义规则是，把字符（unicode）编码成 utf-8，utf-8 是用 1-4 个字节表示的，所以每个字节转换成 16 进制并在前面用百分号（%）连接，最后并把每个字节转换的结果连接起来。\n\n## 响应状态码\n\n### 五类状态码\n\nRFC 标准把状态码分成了以下五类\n\n- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；\n- 2××：成功，报文已经收到并被正确处理；\n- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；\n- 4××：客户端错误，请求报文有误，服务器无法处理；\n- 5××：服务器错误，服务器在处理请求时内部发生了错误。\n\n### 常见响应状态码及含义\n\n- 1xx\n  - **101 Switching Protocols**，客户端要求服务端改成其他协议继续通信，如果服务器统一变更协议，就会返回状态码 101.\n- 2xx\n  - **200 OK**，表示请求成功，通常在响应头后会有 body 数据。\n  - **204 No Content**，也表示请求成功，它与 200 的区别在于，响应头后没有 body 数据。\n  - **206 Partial Content**，常见于获取请求资源的部分数据。“Content-Range”，表示 body 里返回数据的具体范围。\n- 3xx\n  - **301 Moved Permanently**，表示永久重定向。\n  - **302 Found**，表示临时重定向，浏览器不会对临时重定向的内容做缓存优化。\n  - **304 Not Modified**，缓存重定向，用户缓存控制，URL 不包含跳转含义。\n- 4xx\n  - **400 Bad Request**，表示请求错误。\n  - **403 Forbidden**，表示服务器禁止访问资源。\n  - **404 Not Found**，表示资源在服务器上未找到。\n- 5xx\n  - **500 Internal Server Error**，表示服务器发生错误，是一个较通用的错误码。\n  - **502 Bad Gateway**，表示服务器禁止访问资源。\n  - **503 Service Unavailable**，表示服务器正忙，暂时无法响应。\n\n## HTTP 的特点和优缺点\n\n### 五大特点\n\n1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；\n2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；\n3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；\n4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；\n5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。\n\n### 优缺点\n\n- 优点：\n\n  - 灵活可拓展；\n  - 应用广泛，环境成熟；\n  - 无状态，不需要额外资源来记录路状态信息，减轻服务器负担；\n  - 明文传输，数据可直接查看到，方便开发调试。\n\n- 缺点：\n  - 无状态，每次访问都要获取一遍身份信息；\n  - 明文传输，数据容易被截取；\n  - 不安全，数据在传输过程中容易被篡改。"
        }
    ]
}