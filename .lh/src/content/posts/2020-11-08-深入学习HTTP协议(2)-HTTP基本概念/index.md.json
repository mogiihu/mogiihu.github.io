{
    "sourceFile": "src/content/posts/2020-11-08-深入学习HTTP协议(2)-HTTP基本概念/index.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1756112308683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756112329761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,117 +10,233 @@\n ---\n \n > 身为一个前端，HTTP 对我而言就像是云雾环绕的一座山，看不透也不知从哪开始攀登。深入学习 HTTP 协议系列就是我对罗剑锋老师的[《透视 HTTP 协议》](http://gk.link/a/10mzW)所做的总结。希望能对大家的登山之旅有所帮助。\n \n-## HTTP 是什么\n+## 当我们在浏览器地址栏输入网址再按下回车发生了什么？\n \n-HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用来在 www 服务器和本地浏览器互相传输超文本的传送协议，超文本包括文字、图片、音频、视频等内容。\n+1. 浏览器发起域名解析获取地址对应的 IP；\n+2. 浏览器用 TCP 的三次握手与服务器建立连接；\n+3. 浏览器向服务器发送拼好的报文；\n+4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；\n+5. 浏览器解析报文，渲染输出页面。\n \n-## 与 HTTP 相关的概念\n+域名解析的过程中有多级缓存，浏览器先查看自身缓存，没有再向操作系统缓存要，还没有就检查本机域名解析文件 hosts，最后则会用 DNS 域名解析系统进行。在这个过程中可能会经历 CDN 解析，拿到 CDN 服务器的地址\n \n-### HTTP 协议中的两点\n+在达到目标服务器后，通常会经历负载均衡设备，负载均衡设备会访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish。\n \n-一般浏览器是 HTTP 协议中的请求方，服务器是应答方。服务器这里有两个概念，一个是硬件指的是一台机器，另外一个是软件，指的是提供 web 服务的应用程序，运行在硬件服务器上。\n+如果缓存服务器里没有所要数据，就会把请求转发给应用服务器，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。然应用服务器处理完成后把执行的结果返回给负载均衡设备。\n \n-### CDN\n+到达负载均衡后请求的处理就完成了，会按照请求顺序原路返回。\n \n-CDN 全称是 “Content Delivery Network”，内容分发式网络，利用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。\n-CDN 可以缓存源站数据，让浏览器请求更快的得到响应。\n+## HTTP 协议的核心部分 - HTTP 报文\n \n-### 爬虫\n+### 报文结构\n \n-模拟 HTTP 请求端，向服务端发送请求，抓取各种数据。\n+HTTP 协议的请求报文和响应报文的结构由三大部分组成\n \n-### DNS\n+1. 起始行（start line）：描述请求或相应的基本信息；\n+2. 头部字段集合（header）：key-value 的形式；\n+3. 消息正文（entity）：实际传输数据。\n \n-DNS 即**域名系统**，用有意义的名字替代 ip。再使用 TCP/IP 协议通信仍需要 ip 地址，所以需要**域名解析**来将 IP 做一个转换，映射到真实的 IP 上。\n+其中前两部分经常被称为 **请求头/响应头**，正文部分称为**body**。\n \n-### HTTPS\n+HTTP 协议规定报文必须有 header，可以没有 body，在 header 和 body 之间必须有一个空行，如下图所示。\n \n-全称为 “HTTP over SSL/TLS”，即运行在 SSL/TLS 上的 HTTP 服务。SSL/TLS 是一个负责加密的安全协议，基于 TCP/IP 协议之上。\n+![报文结构](./img1.png)\n \n-### 代理\n+### 抓包分析\n \n-HTTP 协议中请求方和应答方的中转站，既可以发送客户端请求，也可以转发服务端应答。\n-常见种类：\n+![抓包分析](./img2.png)\n \n-1. 匿名代理：隐藏被代理机器，只能看到代理服务器；\n-2. 透明代理：跟匿名代理相比完全透明开放，外界既知道代理，也知道客户端；\n-3. 正向代理：靠近客户端，代表客户端向服务端发送请求；\n-4. 反向代理：靠近服务端，代表服务端响应客户端请求；\n-   CDN 其实就是一种代理，代替源服务端响应客户端的请求，起到了一个透明代理和反向代理的作用。\n+图中 1，第一行为请求行部分。2，为 header 部分，3 是空白行部分。这里没有发送 body，所以没有 body 信息。\n \n-## 网络分层模型\n+### 请求行\n \n-### TCP/IP 网络分层模型\n+报文的起始行就是请求行，它简要的描述了客户端想要如何操作服务器端的资源。\n \n-![TCP/IP 网络分层模型](./img1.png)\n+```js\n+GET / HTTP / 1.1;\n+```\n \n-TCP/IP 协议总共有四层，按照图示从下往上的顺序。\n+在抓包获取的信息中，我们可以看到请求头由三部分组成：\n \n-第一层**链接层**：负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。\n+1. 请求方法，表示对资源的操作，对应上面代码中的 GET，；\n+2. 请求目标，通常是一个 URI，表记录请求方法要操作的资源，对应 `/`；\n+3. 版本号：表示报文使用的 HTTP 协议版本，对应 `HTTP/1.1`。\n \n-第二层**网际层/网络互联层**：用 IP 地址取代 MAC 地址，组成落网。\n+这三个部分通常用空格来分隔，最后用 CRLF 换行表示结束，用图片来描述就是下面这个方式。\n \n-第三层**传输层**：保证数据在 IP 地址标记的两点之间传输，是 TCP、UDP 工作的层次。\n+![请求行](./img3.png)\n \n-TCP 与 UDP 的区别：\n-TCP 是一个有状态的协议，需要先于对方建立连接然后才能发送数据，保证数据不丢失。UDP 无状态不用事先连接，但不保证数据会发到对方。TCP 的数据是连续的字节流，有先后顺序。UDP 则是分散的小数据包，顺序发，乱序收。\n+### 状态行\n \n-第四层**应用层**：有各种面向具体应用的协议，如 HTTP、SSH、FTP、Telnet。\n+服务器响应报文里的起始行叫做**状态行**，表示**服务器响应的状态**。\n \n-MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。\n+```js\n+HTTP/1.1 200 OK\n+HTTP/1.1 404 Not Found\n+```\n \n-### OSI 网络分层模型\n+也由三部分组成：\n \n-OSI 全称“开放式系统互联通信参考模型”，从下到上分为七层。\n+1. 版本号，表示报文使用的 HTTP 协议版本号；\n+2. 状态码，表示处理结果，如 200 成功，500 服务器错误；\n+3. 原因：作为数字状态码的补充，在上面代码是 `OK`。\n \n-![image](./img2.png)\n+它的组成规则和请求行一致，用空格来分隔，用 CRLF 换行表示结束，如下图所示。\n \n-1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；\n-2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；\n-3. 第三层：网络层，相当于 TCP/IP 里的网际层；\n-4. 第四层：传输层，相当于 TCP/IP 里的传输层；\n\\ No newline at end of file\n-5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；\n-6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；\n-7. 第七层：应用层，面向具体的应用传输数据。\n+![状态行](./img4.png)\n \n-### 两个分层模型的映射关系\n+### 头部字段（header）\n \n-![image](./img3.png)\n+请求行/状态行加上头部字段（header），就组成了请求头/响应头。\n+如下图所示：\n \n-1. 第一层：物理层，TCP/IP 里无对应；\n-2. 第二层：数据链路层，对应 TCP/IP 的链接层；\n-3. 第三层：网络层，对应 TCP/IP 的网际层；\n-4. 第四层：传输层，对应 TCP/IP 的传输层；\n-5. 第五、六、七层：对应到 TCP/IP 的应用层。\n+![请求头/响应头](./img5.png)\n \n-### TCP/IP 协议栈的工作方式\n+头部字段是 key-value 的形式，之间用 `：` 分隔，最后用 CRLF 换行表示结束。\n \n-HTTP 协议的传输过程通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包向下层发送出去。\n-接收数据时按照从下往上穿过协议层，逐层拆包，拿到数据。\n+注意：\n \n-## 域名\n+1. 字段不区分大小写，不允许出现下划线`_`，可以使用短横线`-`连接。\n+2. key 后面紧跟`:`，不能有空格。但是`:`和 value 之间可以出现空格。\n+3. 字段的顺序是无意义的。\n+4. 字段原则上不能出现重复，除非字段本身语义允许，如 Set-Cookie。\n+5. 在请求头/响应头中只有 `Host` 字段是必须的。\n \n-### 域名的解析\n+## HTTP 请求方法\n \n-域名需要转换成 IP 地址，这个转换的过程叫做**域名解析**。\n+### 标准请求方法\n \n-域名解析采用的是 DNS 系统，除了 DNS 系统外，还会利用各种缓存机制，对 DNS 解析结果做缓存，方便下次能快速找到这个域名对应的 IP。\n+1. GET：获取资源，可以理解为读取或者下载数据；\n+2. HEAD：获取资源的元信息；POST：向资源提交数据，相当于写入或上传数据；\n+3. PUT：类似 POST；DELETE：删除资源；\n+4. CONNECT：建立特殊的连接隧道；\n+5. OPTIONS：列出可对资源实行的方法；\n+6. TRACE：追踪请求 - 响应的传输路径。\n \n-这里的缓存有：\n+![请求分类](./img6.png)\n \n-1. 操作系统缓存；\n-2. host 文件映射；\n-3. 浏览器缓存\n+### 常用方法\n \n-### 利用域名我们可以做什么\n+#### GET 和 HEAD\n \n-1. 重定向；\n-2. 当做名字空间来使用，使内部服务可以直接使用域名来标记；\n-3. 基于域名实现**负载均衡**。\n+GET 的含义是**从服务器获取资源**，可以搭配 URI 和其他头部字段实现对资源更精细的操作。\n \n-基于域名的负载均衡也有两种方式。\n+HEAD 的含义与 GET 类似，都是**从服务器获取资源**，服务器处理机制也一样，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。可以将他看做 GET 的简化版。\n \n-第一种方式，利用域名解析可以返回多个 IP 地址的特性，使一个域名对应多台主机，客户端收到多个 IP 后可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。\n+#### POST 和 PUT\n \n-第二种方式，根据域名解析可以配置内部的策略，返回离客户端最近的主机或者当前服务质量最好的主机，在 DNS 端把请求发送到不同服务器，实现负载均衡。\n+POST 和 PUT 是指**向 URI 指定资源提交数据**，而 POST 和 PUT 的区别在于 POST 意味着“新建”，PUT 则是 “修改”。\n+\n+### 其他方法\n+\n+DELETE：指示服务器删除资源。\n+CONNECT：要求服务器为客户端和另一台远程服务器建立一条通道，浏览器充当代理角色。\n+OPTIONS：要求服务器列出可对资源实行的请求方法。\n+TRACE：用于对 HTTP 链路的测试或诊断。\n+\n+### 安全和幂等\n+\n+**安全**在 HTTP 协议里是指请求方法不会修改服务器上的资源。所以只有 GET 和 HEAD 是安全的，因为它们对资源进行是只读操作。\n+\n+**幂等**意思是多次执行相同操作，结果也都是相同的，即多次“幂”后“相等”。\n+\n+可以看出 GET 和 HEAD 既是安全的也是幂等的，DELETE 是幂等的，POST 和 PUT 既不安全也不幂等。\n+\n+## URI 与 网址\n+\n+URI：**统一资源标识符**，包括 URL 和 URN 两部分。\n+URL：**统一资源定位符**，就是我们俗称的“网络地址”，因为 URL 十分普遍，所以通常用 URL 表示 URL 或 URI。\n+\n+### URL 格式\n+\n+URL 本质上是一个字符串，它的作用是 唯一的标记资源的位置或者名字。它不仅能标记万维网资源，还能标记动态服务资源或者本地资源。\n+\n+它的组成部分如下图所示：由 scheme、host:port、path 和 query 组成。\n+\n+![URL 格式](./img7.png)\n+\n+URI 的第一个组成部分是 **scheme** 代表协议名，表示资源应该用那种协议访问（如：http、ftp、file）。\n+\n+scheme 之后就是固定的三个字符“**://**”，用来把 scheme 和后面的部分分离开。\n+\n+“**://**”之后是 **authority** 部分，表示**资源所在的主机名**，通常形式是 host:port ，即主机名加端口号。主机名必须要有，可以是 IP 地址或域名。端口号可以省略，浏览器等客户端会根据 scheme 使用默认的端口号，例如 HTTP 默认的是 80，HTTPS 默认的是 443。\n+\n+**path** 是用来**标记资源所在位置**。path 采用的是类似路径的表示方式，URI 的 path 必须要以 “/” 开始。\n+\n+看下面这个例子\n+\n+```\n+https://tools.ietf.org/html/rfc7230\n+```\n+\n+`https` 是 scheme，表示使用的是 `https` 协议，`tools.ietf.org` 就是主机名，这里默认访问端口号是 443，路径就是后面的 `/html/rfc7230`。\n+\n+### URI 的查询参数 query\n+\n+在上图 URL path 后还有一个 **query** 部分，query 由一个“?”开始，但不包含“?”，表示对资源附加的额外要求。\n+\n+query 的格式是由 多个 “key=value” 组成，多个 “key=value” 之间用 “&” 连接。\n+\n+### URI 的编码\n+\n+URI 中只能使用 ASCII 码，对于英语以外的汉语、日语及其他字符 URI 会对他们进行 encodeURI 转义。\n+\n+转义规则是，把字符（unicode）编码成 utf-8，utf-8 是用 1-4 个字节表示的，所以每个字节转换成 16 进制并在前面用百分号（%）连接，最后并把每个字节转换的结果连接起来。\n+\n+## 响应状态码\n+\n+### 五类状态码\n+\n+RFC 标准把状态码分成了以下五类\n+\n+- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；\n+- 2××：成功，报文已经收到并被正确处理；\n+- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；\n+- 4××：客户端错误，请求报文有误，服务器无法处理；\n+- 5××：服务器错误，服务器在处理请求时内部发生了错误。\n+\n+### 常见响应状态码及含义\n+\n+- 1xx\n+  - **101 Switching Protocols**，客户端要求服务端改成其他协议继续通信，如果服务器统一变更协议，就会返回状态码 101.\n+- 2xx\n+  - **200 OK**，表示请求成功，通常在响应头后会有 body 数据。\n+  - **204 No Content**，也表示请求成功，它与 200 的区别在于，响应头后没有 body 数据。\n+  - **206 Partial Content**，常见于获取请求资源的部分数据。“Content-Range”，表示 body 里返回数据的具体范围。\n+- 3xx\n+  - **301 Moved Permanently**，表示永久重定向。\n+  - **302 Found**，表示临时重定向，浏览器不会对临时重定向的内容做缓存优化。\n+  - **304 Not Modified**，缓存重定向，用户缓存控制，URL 不包含跳转含义。\n+- 4xx\n+  - **400 Bad Request**，表示请求错误。\n+  - **403 Forbidden**，表示服务器禁止访问资源。\n+  - **404 Not Found**，表示资源在服务器上未找到。\n+- 5xx\n+  - **500 Internal Server Error**，表示服务器发生错误，是一个较通用的错误码。\n+  - **502 Bad Gateway**，表示服务器禁止访问资源。\n+  - **503 Service Unavailable**，表示服务器正忙，暂时无法响应。\n+\n+## HTTP 的特点和优缺点\n+\n+### 五大特点\n+\n+1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；\n+2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；\n+3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；\n+4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；\n+5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。\n+\n+### 优缺点\n+\n+- 优点：\n+\n+  - 灵活可拓展；\n+  - 应用广泛，环境成熟；\n+  - 无状态，不需要额外资源来记录路状态信息，减轻服务器负担；\n+  - 明文传输，数据可直接查看到，方便开发调试。\n+\n+- 缺点：\n+  - 无状态，每次访问都要获取一遍身份信息；\n+  - 明文传输，数据容易被截取；\n+  - 不安全，数据在传输过程中容易被篡改。\n\\ No newline at end of file\n"
                },
                {
                    "date": 1756112647956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n ---\n title: 深入学习HTTP协议(2)-HTTP基本概念\n-published: 2020-11-08 15:13:43\n+published: 2020-11-08\n description: ''\n image: ''\n tags: [HTTP]\n category: 'HTTP'\n"
                }
            ],
            "date": 1756112308683,
            "name": "Commit-0",
            "content": "---\ntitle: 深入学习HTTP协议(2)-HTTP基本概念\npublished: 2020-11-08 15:13:43\ndescription: ''\nimage: ''\ntags: [HTTP]\ncategory: 'HTTP'\ndraft: false \nlang: ''\n---\n\n> 身为一个前端，HTTP 对我而言就像是云雾环绕的一座山，看不透也不知从哪开始攀登。深入学习 HTTP 协议系列就是我对罗剑锋老师的[《透视 HTTP 协议》](http://gk.link/a/10mzW)所做的总结。希望能对大家的登山之旅有所帮助。\n\n## HTTP 是什么\n\nHTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用来在 www 服务器和本地浏览器互相传输超文本的传送协议，超文本包括文字、图片、音频、视频等内容。\n\n## 与 HTTP 相关的概念\n\n### HTTP 协议中的两点\n\n一般浏览器是 HTTP 协议中的请求方，服务器是应答方。服务器这里有两个概念，一个是硬件指的是一台机器，另外一个是软件，指的是提供 web 服务的应用程序，运行在硬件服务器上。\n\n### CDN\n\nCDN 全称是 “Content Delivery Network”，内容分发式网络，利用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。\nCDN 可以缓存源站数据，让浏览器请求更快的得到响应。\n\n### 爬虫\n\n模拟 HTTP 请求端，向服务端发送请求，抓取各种数据。\n\n### DNS\n\nDNS 即**域名系统**，用有意义的名字替代 ip。再使用 TCP/IP 协议通信仍需要 ip 地址，所以需要**域名解析**来将 IP 做一个转换，映射到真实的 IP 上。\n\n### HTTPS\n\n全称为 “HTTP over SSL/TLS”，即运行在 SSL/TLS 上的 HTTP 服务。SSL/TLS 是一个负责加密的安全协议，基于 TCP/IP 协议之上。\n\n### 代理\n\nHTTP 协议中请求方和应答方的中转站，既可以发送客户端请求，也可以转发服务端应答。\n常见种类：\n\n1. 匿名代理：隐藏被代理机器，只能看到代理服务器；\n2. 透明代理：跟匿名代理相比完全透明开放，外界既知道代理，也知道客户端；\n3. 正向代理：靠近客户端，代表客户端向服务端发送请求；\n4. 反向代理：靠近服务端，代表服务端响应客户端请求；\n   CDN 其实就是一种代理，代替源服务端响应客户端的请求，起到了一个透明代理和反向代理的作用。\n\n## 网络分层模型\n\n### TCP/IP 网络分层模型\n\n![TCP/IP 网络分层模型](./img1.png)\n\nTCP/IP 协议总共有四层，按照图示从下往上的顺序。\n\n第一层**链接层**：负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。\n\n第二层**网际层/网络互联层**：用 IP 地址取代 MAC 地址，组成落网。\n\n第三层**传输层**：保证数据在 IP 地址标记的两点之间传输，是 TCP、UDP 工作的层次。\n\nTCP 与 UDP 的区别：\nTCP 是一个有状态的协议，需要先于对方建立连接然后才能发送数据，保证数据不丢失。UDP 无状态不用事先连接，但不保证数据会发到对方。TCP 的数据是连续的字节流，有先后顺序。UDP 则是分散的小数据包，顺序发，乱序收。\n\n第四层**应用层**：有各种面向具体应用的协议，如 HTTP、SSH、FTP、Telnet。\n\nMAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。\n\n### OSI 网络分层模型\n\nOSI 全称“开放式系统互联通信参考模型”，从下到上分为七层。\n\n![image](./img2.png)\n\n1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；\n2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；\n3. 第三层：网络层，相当于 TCP/IP 里的网际层；\n4. 第四层：传输层，相当于 TCP/IP 里的传输层；\n5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；\n6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；\n7. 第七层：应用层，面向具体的应用传输数据。\n\n### 两个分层模型的映射关系\n\n![image](./img3.png)\n\n1. 第一层：物理层，TCP/IP 里无对应；\n2. 第二层：数据链路层，对应 TCP/IP 的链接层；\n3. 第三层：网络层，对应 TCP/IP 的网际层；\n4. 第四层：传输层，对应 TCP/IP 的传输层；\n5. 第五、六、七层：对应到 TCP/IP 的应用层。\n\n### TCP/IP 协议栈的工作方式\n\nHTTP 协议的传输过程通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包向下层发送出去。\n接收数据时按照从下往上穿过协议层，逐层拆包，拿到数据。\n\n## 域名\n\n### 域名的解析\n\n域名需要转换成 IP 地址，这个转换的过程叫做**域名解析**。\n\n域名解析采用的是 DNS 系统，除了 DNS 系统外，还会利用各种缓存机制，对 DNS 解析结果做缓存，方便下次能快速找到这个域名对应的 IP。\n\n这里的缓存有：\n\n1. 操作系统缓存；\n2. host 文件映射；\n3. 浏览器缓存\n\n### 利用域名我们可以做什么\n\n1. 重定向；\n2. 当做名字空间来使用，使内部服务可以直接使用域名来标记；\n3. 基于域名实现**负载均衡**。\n\n基于域名的负载均衡也有两种方式。\n\n第一种方式，利用域名解析可以返回多个 IP 地址的特性，使一个域名对应多台主机，客户端收到多个 IP 后可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。\n\n第二种方式，根据域名解析可以配置内部的策略，返回离客户端最近的主机或者当前服务质量最好的主机，在 DNS 端把请求发送到不同服务器，实现负载均衡。"
        }
    ]
}